<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MQ 笔记</title>
      <link href="/2024/05/20/MQ-%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/05/20/MQ-%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="MQ-优点"><a href="#MQ-优点" class="headerlink" title="MQ 优点"></a>MQ 优点</h2><h3 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h3><p>如果存在A、B、C三个系统，A是生产者，B、C是消费者。通过Pub/Sub 发布订阅消息模型，A只需要负责生产消息发送到 MQ，不需要考虑B、C系统的情况。</p><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>相较于同步，MQ 可以异步接受A系统的消息并快速响应用户请求，时延只考虑A系统。如果没有 MQ，会同步发送消息到B、C系统，调用时延会变成A+B+C，用户请求响应会变慢。</p><h3 id="削峰"><a href="#削峰" class="headerlink" title="削峰"></a>削峰</h3><p>比如用餐高峰期，消息消费者消费消息的能力有限，这时引入 MQ ，将来不及处理的消息存入 MQ 慢慢消费，等待高峰期过去很快就能将堆积的消息处理。</p><h2 id="MQ-缺点"><a href="#MQ-缺点" class="headerlink" title="MQ 缺点"></a>MQ 缺点</h2><ul><li><p><strong>可用性降低</strong>，一旦 MQ 挂掉系统就不能用了</p></li><li><p><strong>复杂度提高</strong>，需要考虑的情况变多了，如消息是否重复消费、消息是否丢失、消息传递的顺序性等等</p></li><li><strong>一致性问题</strong>，由于A系统只需要考虑消息成功发送出去，如果消费者某一个系统挂掉了，那么数据会存在不一致的问题</li></ul><h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><h3 id="RabbitMQ-高可用"><a href="#RabbitMQ-高可用" class="headerlink" title="RabbitMQ 高可用"></a>RabbitMQ 高可用</h3><p>部署有三种模式：</p><ul><li><p>单机：不常用</p></li><li><p>集群：增加吞吐量，每个 MQ 实例消息不同步，不保证高可用。如果开启消息持久化可以保证消息不丢失。</p></li><li><p><strong>镜像集群</strong>：每个 MQ 实例队列的消息会同步，保证消息的高可用。</p><ul><li>如何开启镜像集群：在普通集群的基础上，配置后台Admin策略</li></ul></li></ul><p><a href="https://developer.aliyun.com/article/988115">参考链接</a></p><h3 id="Kafka-高可用"><a href="#Kafka-高可用" class="headerlink" title="Kafka 高可用"></a>Kafka 高可用</h3><p>每个实例会根据<code>topic</code>划分为为多个<code>partition</code>。从0.8版本开始，Kafka 引入了<code>replica</code>（副本。每个 partition 会产生多个 replica 到不同的机器上），所有的 replica 会作为 follower 选举出一个<code>leader</code>，生产者和消费者只需要和<code>leader</code>进行数据传输，并同步消息到每个<code>follower</code>。leader 宕机了也不要紧，会从其他<code>follower</code>重新选举出<code>leader</code>，数据也不会丢失。</p><p>生产者发送消息到<code>leader</code>，其他<code>follower</code>会pull<code>leader</code>的数据，所有的<code>follower</code>同步好数据后会发送<code>ack</code>到<code>leader</code>，<code>leader</code>收到这个<code>ack</code>才会将消息成功接受的信息返回给生产者。</p><p>消费者只会从<code>leader</code>中读取数据。</p><h2 id="不重复消费"><a href="#不重复消费" class="headerlink" title="不重复消费"></a>不重复消费</h2><p>MQ 本身都有可能出现重复消费的情况，需要靠消费者保证不重复消费。解决方案是给每条消息生成唯一ID存入Redis，消费时查询ID来判断消息是否消费过。</p><p>如果发生了重复消费的情况，要保证<strong>消息幂等性</strong>，可以通过如下方法：</p><ul><li><p>数据库存在主键唯一约束，不会插入相同数据</p></li><li><p>Redis使用Set类型保存数据，不会存在重复数据</p></li></ul><h2 id="消息可靠传输"><a href="#消息可靠传输" class="headerlink" title="消息可靠传输"></a>消息可靠传输</h2><h3 id="RabbitMQ-保证消息可靠"><a href="#RabbitMQ-保证消息可靠" class="headerlink" title="RabbitMQ 保证消息可靠"></a>RabbitMQ 保证消息可靠</h3><p>交换机是否开启持久化不影响消息可靠性，所以开启持久化，分两步：</p><ul><li><p>开启队列持久化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数1 queue ：队列名  </span></span><br><span class="line"><span class="comment">// 参数2 durable ：是否持久化  </span></span><br><span class="line"><span class="comment">// 参数3 exclusive ：仅创建者可以使用的私有队列，断开后自动删除  </span></span><br><span class="line"><span class="comment">// 参数4 autoDelete : 当所有消费客户端连接断开后，是否自动删除队列  </span></span><br><span class="line"><span class="comment">// 参数5 arguments  </span></span><br><span class="line">channel.queueDeclare(QUEUE_NAME, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>);  </span><br></pre></td></tr></table></figure></li><li><p>开启消息持久化，将消息的 <code>deliveryMode</code> 设置为 2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数1 exchange ：交换器  </span></span><br><span class="line"><span class="comment">// 参数2 routingKey ： 路由键  </span></span><br><span class="line"><span class="comment">// 参数3 props ： 消息的其他参数,其中 MessageProperties.PERSISTENT_TEXT_PLAIN 表示持久化  </span></span><br><span class="line"><span class="comment">// 参数4 body ： 消息体  </span></span><br><span class="line">channel.basicPublish(<span class="string">&quot;&quot;</span>, queue_name, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes());  </span><br></pre></td></tr></table></figure></li></ul><h3 id="生产者保证消息可靠"><a href="#生产者保证消息可靠" class="headerlink" title="生产者保证消息可靠"></a>生产者保证消息可靠</h3><ul><li><p><strong>开启事务消息</strong></p><p>开启后，如果消息未被接受，会发生异常回滚事务，然后重试发送消息。这样虽然保证了消息可靠性，但是事务是同步的，会导致系统吞吐量下降。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过工厂创建连接</span></span><br><span class="line">connection = factory.newConnection();</span><br><span class="line"><span class="comment">// 获取通道</span></span><br><span class="line">channel = connection.createChannel();</span><br><span class="line"><span class="comment">// 开启事务</span></span><br><span class="line">channel.txSelect();</span><br><span class="line"><span class="comment">// 这里发送消息</span></span><br><span class="line">channel.basicPublish(exchange, routingKey, MessageProperties.PERSISTENT_TEXT_PLAIN, msg.getBytes());</span><br><span class="line"><span class="comment">// 提交事务</span></span><br><span class="line">channel.txCommit();</span><br><span class="line"></span><br><span class="line">... 发生异常</span><br><span class="line">    </span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 捕捉异常，回滚事务</span></span><br><span class="line">    channel.txRollback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>发送方开启<code>confirm</code>模式</strong></p><p>每次写的消息都会分配一个唯一的 id，然后如果写入了 RabbitMQ 中，RabbitMQ 会给你回传一个 <code>ack</code> 消息，告诉你说这个消息 ok 了。如果 RabbitMQ 没能处理这个消息，会回调你的一个 <code>nack</code> 接口，告诉你这个消息接收失败，你可以重试。</p><ul><li><p>普通 Confirm 模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启用confirm模式</span></span><br><span class="line">channel.confirmSelect();</span><br><span class="line"><span class="comment">// 发送消息，可以发送多条或单条</span></span><br><span class="line">channel.basicPublish(ConfirmConfig.exchangeName, ConfirmConfig.routingKey, MessageProperties.PERSISTENT_TEXT_PLAIN, ConfirmConfig.msg_10B.getBytes());</span><br><span class="line"><span class="comment">// 判断消息是否发送成功</span></span><br><span class="line"><span class="keyword">if</span> (!channel.waitForConfirms()) &#123;</span><br><span class="line">    <span class="comment">// 消息发送失败</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>异步 Confirm 模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">channel.confirmSelect();</span><br><span class="line"><span class="comment">// 监听确认消息和未确认消息</span></span><br><span class="line">channel.addConfirmListener(<span class="keyword">new</span> <span class="title class_">ConfirmListener</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleAck</span><span class="params">(<span class="type">long</span> deliveryTag, <span class="type">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (multiple) &#123;</span><br><span class="line">            confirmSet.headSet(deliveryTag + <span class="number">1</span>).clear();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            confirmSet.remove(deliveryTag);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleNack</span><span class="params">(<span class="type">long</span> deliveryTag, <span class="type">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Nack, SeqNo: &quot;</span> + deliveryTag + <span class="string">&quot;, multiple: &quot;</span> + multiple);</span><br><span class="line">        <span class="keyword">if</span> (multiple) &#123;</span><br><span class="line">            confirmSet.headSet(deliveryTag + <span class="number">1</span>).clear();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            confirmSet.remove(deliveryTag);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="消费者保证消息可靠"><a href="#消费者保证消息可靠" class="headerlink" title="消费者保证消息可靠"></a>消费者保证消息可靠</h3><p>声明队列时，指定队列中的 noAck 参数，当 noAck=false，RabbitMQ 会等待消费者显式发回 ack 信号后，才从内存（和磁盘，如果是持久化消息）中移去消息。否则，一旦消息被消费者消费，RabbitMQ 会在队列中立即删除它。</p><h2 id="消息顺序传输"><a href="#消息顺序传输" class="headerlink" title="消息顺序传输"></a>消息顺序传输</h2><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><p>生成多个Queue队列，一个消费者对应一个Queue</p><h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><p>根据 Key 将数据发送到不同的内存queue，一个线程对应一个内存queue</p><h2 id="失败、过期消息处理"><a href="#失败、过期消息处理" class="headerlink" title="失败、过期消息处理"></a>失败、过期消息处理</h2><p>RabbitMQ中的死信队列专门处理这种消息，对于<code>TTL 超时</code>或<code>被拒绝</code>或<code>超过队列最大长度后</code>的消息，不会直接删除，会进入死信队列</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
